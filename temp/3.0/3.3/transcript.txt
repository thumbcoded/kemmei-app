you often hear the term memory
0:03
associated with computers how much
0:05
memory is in your computer is your
0:07
computer running out of memory when
0:09
we're talking about memory we are
0:11
referring to random access memory or RAM
0:15
this is the most common type of memory
0:17
that you will find inside of our
0:19
computers but of course it's not the
0:21
only type of memory you might run into
0:23
when we refer to RAM we're not referring
0:25
to any long-term storage you might have
0:27
in your computer ram is not referring to
0:29
a hard drive or SSD and you want to be
0:32
very careful about differentiating
0:34
between random access memory and the
0:36
long-term storage that you might have in
0:38
a hard drive ram is temporary high-speed
0:42
storage that we use when we are
0:44
executing applications and performing
0:46
calculations in our computer the only
0:49
way your computer can work with data is
0:51
if that data has been loaded into the
0:53
RAM of your computer so it's very common
0:56
to load applications and data from your
0:58
storage drive into active memory of your
1:01
computer process that data in some way
1:04
and very often we may need to store that
1:06
result back onto your hard drive or your
1:09
SSD we've seen a number of changes to
1:12
memory technology through the years and
1:14
every few years we tend to update and
1:16
make enhancements to the memory that
1:19
we're using inside of our computers the
1:21
speed of your memory is often associated
1:23
with the overall performance of your
1:26
computer if you have faster memory then
1:28
you tend to have a faster computer but a
1:31
single stick of memory is not generally
1:34
compatible with every computer you might
1:36
find every motherboard is slightly
1:38
different in what it expects from your
1:40
system memory so if you're ever
1:42
performing a memory upgrade or you're
1:44
moving memory from one system to another
1:46
be sure to check the documentation of
1:48
your system to make sure that the memory
1:50
you're installing is compatible with
1:52
that
1:53
motherboard instead of having individual
1:55
memory chips that we would install or
1:58
remove from a motherboard we have a
2:01
single memory module we refer to this as
2:03
a DIM or dual inline memory module the
2:07
reason we refer to this as dual inline
2:09
memory module is that one side of this
2:12
module has a series of electrical
2:14
contacts if we turn this module over
2:16
there are also another set of electrical
2:19
contacts on the other side and the
2:21
contacts you see on this side of the
2:23
memory module are different than the
2:25
contacts you see on the other side of
2:27
the memory module since there are two
2:30
separate lines of contacts we refer to
2:32
this as a dual inline memory module you
2:35
might also see that information that is
2:37
written or read for memory is done in
2:40
64-bit blocks we refer to this as the
2:43
data width of memory so if you ever
2:45
perform any calculations on how much
2:47
information you're reading or writing
2:49
from memory you'll notice those
2:51
calculations use a 64bit data width
2:55
since we are putting all of these
2:57
individual chips on a single memory
2:59
module it makes it very easy to install
3:01
and remove from a motherboard you can
3:04
install and remove the entire DIM at one
3:06
time by simply pushing it into the slot
3:09
to remove this module you would pull
3:11
back the locks that are on the side of
3:12
the module and simply pull the module
3:14
directly out of the
3:16
motherboard if you're working on a
3:18
laptop or another mobile device then
3:20
you're probably not using a full-size
3:22
DIM in order to shrink things down into
3:25
that smaller size required for a
3:27
portable device we use a smaller version
3:29
of a dim referred to as a so dim this is
3:33
a small outline dual inline memory
3:35
module and it's about half the size of a
3:38
normal DIM if you need to add or upgrade
3:40
memory in a laptop you're probably going
3:42
to install a SO DIM the process for
3:46
installing memory into a laptop is very
3:48
similar to the process you would use for
3:50
a desktop computer although you'll
3:52
notice very often those memory modules
3:54
in a laptop are installed horizontally
3:57
to save room you would slide the memory
3:59
module in push it down and it will lock
4:01
in place with the locks on the side of
4:03
the memory
4:04
module here you can see the difference
4:07
in size between a DIM which is the
4:09
longer module on the top and a SOM you
4:12
can see that the smaller size of the SOM
4:15
does make it a better choice for mobile
4:17
and laptop devices on the DIM are
4:20
installed individual memory chips those
4:23
chips are dynamic random access memory
4:25
we refer to this as random access memory
4:27
because you can access any data on any
4:30
of these memory chips at any time
4:33
instantaneously we don't have to fast
4:34
forward or rewind through the memory
4:36
like you might have to do with a
4:38
magnetic tape we can instead reference
4:41
exactly the data we need by simply
4:43
referring to its address in this memory
4:45
chip the type of dynamic random access
4:48
memory that we use in our computers is a
4:51
version that is synchronous or SD RAM
4:54
synchronous dynamic random access memory
4:57
is one that is synchronized to a common
4:59
clock inside of your computer that
5:02
common clock keeps data moving inside
5:04
your computer at a very standard rate
5:06
and since the CPU and memory inside of
5:08
your computer is running at such a high
5:10
rate of speed having this common clock
5:13
allows many of the components inside of
5:15
your computer to keep track of a
5:17
standard rate of data that may be
5:19
transferred back and forth
5:21
there's another interesting technology
5:23
that memory uses to be able to transfer
5:26
data at higher rates of speed an older
5:28
style of memory used a single data rate
5:31
to be able to transfer information from
5:33
memory into CPU and then back again and
5:36
it used the clock rate to be able to
5:38
manage this transfer of data one single
5:41
clock cycle would result in one bit of
5:43
data being transferred the next clock
5:46
cycle would be the next bit of data and
5:48
the next clock cycle would have a third
5:50
bit of data in order to improve on that
5:53
data transfer we introduced a new type
5:55
of memory technology known as double
5:58
data rate this DDR memory can transfer
6:01
information at the top and the bottom of
6:04
the clock cycle effectively doubling how
6:06
much information can be transferred from
6:08
memory to CPU and back again so going up
6:12
on one clock cycle would be one data
6:14
transfer going down on that clock cycle
6:17
would be another data transfer and you
6:19
can see that we have effectively doubled
6:21
the amount of information that we can
6:23
transfer over exactly the same amount of
6:25
time the memory that you use inside of
6:28
your computer is double data rate memory
6:30
you'll see it often represented as DDR
6:34
and there will be a number next to the
6:35
DDR to designate the version of DDR
6:38
that's installed for example your
6:40
computer may have DDR3 memory inside of
6:43
it this is a memory module that was
6:46
upgraded from the older DDR2 and
6:48
although it could increase the total
6:50
capacity that we could have on a single
6:52
memory module it was not backwards
6:55
compatible with the older DDR2 so if you
6:58
were upgrading to a motherboard that
7:00
supported DDR3 memory you would not be
7:02
able to move over your older DDR2 memory
7:06
you might also find that your computer
7:08
supports a faster type of memory known
7:11
as DDR4 ddr4 also increased speeds over
7:15
the older DDR3 technologies and because
7:18
this is a newer style and technology of
7:21
memory it is not backwards compatible
7:23
with earlier versions of DDR with DDR5
7:27
we improved on DDR4 by increasing the
7:30
speed of the data transfers between the
7:32
memory module and the CPU on the
7:34
motherboard and this is one that also is
7:37
not backwards compatible with that older
7:40
memory and if we were to come out with a
7:42
new version of memory with new types of
7:44
technologies it's very likely that the
7:47
newer technologies would also not be
7:50
backwards
7:51
compatible fortunately we built in
7:53
engineering into these memory modules
7:55
that would prevent it from being
7:57
installed into the wrong motherboard if
8:00
you look closely at the memory modules
8:02
themselves there are small keys or holes
8:05
at the bottom of the memory module that
8:07
correlate to a key that's on the
8:09
motherboard itself this means that a
8:11
DDR2 module can only fit into a
8:13
motherboard specifically designed to fit
8:16
that particular key space if you were
8:18
installing DDR4 memory on a DDR3
8:21
motherboard you would see that those
8:23
memory modules would not fit because the
8:26
key is in the wrong location

the memory modules that we use inside of
0:04
our computers can be different depending
0:06
on what that system is used for If it's
0:08
for a desktop computer at home it might
0:10
have standard memory inside of it But if
0:13
we're using this inside of a server we
0:15
might need memory that has some
0:17
additional capabilities So if you're
0:19
running a web server database server or
0:21
any other important service you might
0:24
want to use one of these memory types
0:26
The first memory type you might want to
0:28
consider is par memory This is memory
0:31
that includes an extra par bit with each
0:33
bite that is stored in the memory This
0:36
will not always detect errors that may
0:39
have occurred in that memory and it's
0:41
not able to correct every error but it
0:44
can tell you that a memory error has
0:46
occurred This often requires the system
0:48
halting and requires a full reboot but
0:50
at least you were informed where the
0:52
problem was occurring Well if you were
0:54
able to recognize an error with the
0:57
memory then it might be possible to
0:59
correct that error If you are running
1:02
ECC memory you would be able to provide
1:05
that correction ECC is error correction
1:08
code It not only determines that a
1:10
memory error has occurred it can correct
1:13
that error and the system will continue
1:15
to run normally Physically the memory
1:18
modules that you would use for standard
1:20
memory parody memory or ECC memory are
1:23
all about the same size They look very
1:26
similar and you'd have to look at the
1:28
details of those memory specifications
1:31
to even know there's a difference
1:32
between those different memory types So
1:35
how are these memory types able to
1:38
recognize that an error has occurred
1:41
It's able to do it because it's saving
1:43
some extra information in that memory
1:45
called a par bit It's able to look at an
1:49
entire bite of data A bite being of
1:51
course 8 bits in length And it adds
1:54
effectively a ninth bit to that
1:56
particular bite In most systems the par
1:59
bit that we use is referred to as even
2:01
par because the bit that we're going to
2:04
add will make all of these bits add up
2:06
to an even number Let's give it a shot
2:09
and see if we can calculate the par bits
2:12
for these three bytes We'll start with
2:14
the first bite across the top which is 1
2:17
1 0 0 1 1 If we were to add up all of
2:22
the ones in this particular bite there
2:24
would be 1 2 3 4 5 6 This means that we
2:28
already have an even number for this
2:30
particular bite which means our par bit
2:33
would not add any additional bits we
2:36
would instead add the par bit as a zero
2:39
Let's try another one We have 0 0
2:42
0 1 0 If we count up the number of ones
2:46
we have one which means it's an odd
2:48
number So to make this even par we need
2:51
to make our par bit a 1 And now all of
2:54
the ones on that line add up to an even
2:57
number And let's do a third bite This
2:59
one is 1 0 0 1 1 0 0 And if we count the
3:04
number of ones there is 1 2 3 1's So
3:07
that is an odd number To make this even
3:10
par our par bit then needs to be one And
3:14
now we have par that we've calculated
3:16
for all three of these bytes on our
3:19
system When we're writing this
3:21
information into memory we would write
3:23
it with not only the eight bits of the
3:25
bite but we would include the par bit in
3:27
that storage as well When we retrieve
3:29
this information from memory we evaluate
3:32
this bite We perform our own par check
3:35
and then we compare that par bit to the
3:37
one that was stored in memory If those
3:39
par bits are identical then we can
3:41
assume that that particular bite is
3:43
intact and there's no errors And if
3:45
those par bits are different then we
3:47
know some type of error has occurred
3:49
either with the process of writing that
3:51
information to memory or reading that
3:53
information from the memory module So
3:56
let's perform our own par checks Here's
3:58
information that has already been stored
4:00
in memory Let's retrieve this from
4:02
memory and see if it matches what we
4:04
would expect Let's look at the first
4:06
bite which is
4:09
000000111 We know that if we count those
4:11
up that is odd number which means the
4:14
par bit should be a one and in this case
4:16
the par bit that we pulled from memory
4:18
is a one So that particular memory is
4:21
valid Let's go with the next bite which
4:23
is 0 0
4:25
0 1 0 We see that this is an odd number
4:29
So to make this even par our par value
4:32
would need to be a one But the par value
4:34
in this case is a zero which means some
4:37
type of error has occurred with that
4:39
bite And lastly we have 0 1 1 0 0 1 0 0
4:44
If we count the number of ones we have
4:46
three which means we need to add one
4:48
more to the par bit Indeed that is
4:51
already a one which means that
4:52
particular bite does not have an error
4:56
If you were to examine the amount of
4:58
data that's moving around your computer
5:00
you would find an enormous amount of
5:03
data being transferred between the
5:05
memory and the CPU This is what we refer
5:08
to as the memory bandwidth And it is an
5:10
important measurement to determine just
5:12
how fast your computer is able to
5:14
operate We often refer to this data
5:17
transfer rate in mega transfers or MT
5:21
per second This refers to million
5:23
transfers per second If you were to look
5:26
at a memory module one that you were
5:28
either purchasing online or at a store
5:30
it might say that it is a 32 GB DDR5
5:33
memory module or a 1x32 GB And it also
5:38
might tell you that this module supports
5:41
5,600 million transfers per second This
5:44
is why the memory bandwidth that's on a
5:47
particular motherboard is such an
5:48
important statistic If we want to
5:51
increase the speed of a system we would
5:53
generally need to increase that data
5:55
rate between the CPU and the memory One
5:59
of the challenges we have with
6:01
constantly increasing these speeds is
6:03
that eventually we hit a maximum of what
6:06
is humanly possible So if you're moving
6:09
information from memory into a CPU and
6:12
then back to memory again you may find
6:14
that you're able to max out the total
6:16
amount of throughput available over that
6:18
particular pathway One of the challenges
6:21
with this is that the CPU has quite a
6:23
bit of idle time while it's waiting for
6:25
this transfer to occur from memory to
6:28
CPU and then back again While that's
6:30
going on we could be performing other
6:32
calculations But the problem is that the
6:35
bandwidth between these two is not
6:36
enough to support the overall speed of
6:39
the CPU In order to increase these
6:41
throughputs we might add an additional
6:44
channel between the CPU and the memory
6:46
This allows the CPU to communicate to
6:49
multiple memory modules simultaneously
6:51
thereby increasing the overall
6:53
throughput of your system If you were to
6:56
look at your computer it may support
6:58
multi-channel memory which could
6:59
potentially double the total throughput
7:02
between your memory and your
7:04
CPU If you check your motherboard
7:06
documentation you may see the
7:07
motherboard supports dual channel memory
7:10
triple channel memory or even quad
7:12
channel memory This means that you could
7:14
add two three or four separate memory
7:16
modules inside of your computer and
7:19
increase the total throughput of that
7:21
memory bandwidth by that total amount If
7:24
you are planning to implement
7:25
multi-channel memory it's very useful to
7:28
have memory combinations that match each
7:30
other So the modules that you would
7:32
install for dual channel triple channel
7:34
or quad channel should all be the same
7:37
type of memory ideally even the same
7:39
make and model The motherboard
7:41
manufacturers have tried to make this a
7:43
little bit easier for us by coloring the
7:45
different slots in the memory modules So
7:48
on your motherboard there might be two
7:50
different colors of slots This
7:52
particular motherboard supports dual
7:54
channel memory and there are two
7:56
separate dual channel configurations One
7:59
that is colored with the black memory
8:01
slots and one that is colored with the
8:02
red memory slots So on this motherboard
8:05
if you wanted to install this into a
8:07
dual channel configuration you would add
8:09
memory modules into the slots that had
8:11
the same color This is one of the
8:13
reasons you might often find your
8:15
systems being shipped with two 16 gig
8:18
memory modules rather than one single 32
8:21
gig memory module Even though the total
8:24
amount of memory is exactly the same in
8:26
those two systems having two separate
8:28
memory modules provides additional
8:30
throughput between your CPU and your
8:33
memory